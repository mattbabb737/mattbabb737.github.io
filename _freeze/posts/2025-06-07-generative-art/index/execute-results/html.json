{
  "hash": "f87386991f7d42388a13d7d85ae4c00c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Generative Art\"\ndescription: \"Explore algorithmic aesthetics by using iterative functions to create mathematical art.\"\nauthor:\n  - name: Matt Babb\ndate: 06-07-2025\ncategories: [Quarto, R] # self-defined categories\nimage: vortex_spin_final.gif\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\neditor: source\nembed-resources: true\necho: true\nwarning: false\nerror: false\ncode-fold: true\ncode-tools: true\n---\n\n## Code Choices (Exhibit 1)\n\nTo create this vortex, I wrote a function called `make_petal()` that places 150 petals in a circular pattern using trigonometry. I adjusted the inner and outer radius and the petal width, which allowed me to shape the form and density of the design. I used the “FantasticFox1” palette (I'm a big WA fan) and applied a mirrored gradient to give the piece a warm-to-cool symmetry. I also softened the borders with a faint black outline for a more smooth and delicate effect.\n\nThe animated version uses the same base pattern but rotates it over 500 frames, creating a slow, mesmerizing spin. I created the GIF using `gifski_renderer()` and embedded it into the document to keep the rendering process efficient.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_petal <- function(n_petals = 150,\n                       inner_radius = 1,\n                       outer_radius = 2.999,\n                       width = 0.1) {\n  \n  angles <- seq(0, 2 * pi - (2 * pi / n_petals),\n                length.out = n_petals)\n\n  tibble(petal = 1:n_petals, angle = angles) %>%\n    rowwise() %>%\n    mutate(\n      x = list(c(\n        0,\n        inner_radius * cos(angle - width),\n        outer_radius * cos(angle),\n        inner_radius * cos(angle + width)\n      )),\n      y = list(c(\n        0,\n        inner_radius * sin(angle - width),\n        outer_radius * sin(angle),\n        inner_radius * sin(angle + width)\n      )),\n      id = petal\n    ) %>%\n    unnest(c(x, y)) %>%\n    ungroup() %>%\n    mutate(\n      gradient = abs(2 * (id - 1) / (n_petals - 1) - 1)\n    )\n}\n\n# Create data\ndf <- make_petal(n_petals = 150)\n\n# Palette\nfox_colors <- wes_palette(\"FantasticFox1\")\nmirror_palette <- colorRampPalette(fox_colors)(100)\n\n# Plot with faint borders\nggplot(df, aes(x, y, group = id, fill = gradient)) +\n  geom_polygon(color = rgb(0, 0, 0, 0.05),\n               alpha = 0.95,\n               linejoin = \"mitre\",\n               size = 0.5) +\n  scale_fill_gradientn(colors = mirror_palette) +\n  coord_equal() +\n  theme_void() +\n  guides(fill = \"none\") +\n  ggtitle(\"1. Spectral Event Horizon [Static]\") +\n  theme(plot.title = element_text(size = 30,\n                                  hjust = 0.5,\n                                  face = \"bold\")\n        )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(wesanderson)\nlibrary(gganimate)\nlibrary(gifski)\n\n# Petal data function with frame-based rotation\nmake_petal <- function(n_petals = 150,\n                       frames = 60,\n                       inner_radius = 1,\n                       outer_radius = 2.999,\n                       width = 0.1) {\n  \n  angles <- seq(0, 2 * pi - (2 * pi / n_petals), length.out = n_petals)\n \n  base <- tibble(petal = 1:n_petals, angle = angles) %>%\n    rowwise() %>%\n    mutate(\n      x_base = list(c(\n        0,\n        inner_radius * cos(angle - width),\n        outer_radius * cos(angle),\n        inner_radius * cos(angle + width)\n      )),\n      y_base = list(c(\n        0,\n        inner_radius * sin(angle - width),\n        outer_radius * sin(angle),\n        inner_radius * sin(angle + width)\n      )),\n      id = petal\n    ) %>%\n    unnest(c(x_base, y_base)) %>%\n    ungroup() %>%\n    mutate(\n      gradient = abs(2 * (id - 1) / (n_petals - 1) - 1)\n    )\n\n  # Duplicate data across frames and rotate\n  expand_grid(base, frame = 1:frames) %>%\n    mutate(\n      theta = 2 * pi * (frame - 1) / frames,  # rotation per frame\n      x = x_base * cos(theta) - y_base * sin(theta),\n      y = x_base * sin(theta) + y_base * cos(theta)\n    )\n}\n\ndf <- make_petal(n_petals = 100, frames = 500)  # fewer petals + frames\n\np <- ggplot(df, aes(x, y, group = interaction(id, frame), fill = gradient)) +\n  geom_polygon(color = rgb(0, 0, 0, 0.05),\n               alpha = 0.95,\n               size = 0.3,\n               linejoin = \"mitre\") +\n  scale_fill_gradientn(colors = mirror_palette) +\n  coord_equal() +\n  theme_void() +\n  guides(fill = \"none\") +\n  ggtitle(\"Spining\") +\n  transition_manual(frame)\n\nanimation <- animate(\n  p,\n  fps = 25,\n  duration = 10,\n  width = 500,\n  height = 500,\n  res = 100,\n  renderer = gifski_renderer(),\n  verbose = TRUE\n)\n```\n:::\n\n\n::: text-center\n# 1. Spectral Event Horizon \\[GIF\\]\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::include_graphics(\"vortex_spin_final.gif\")\n```\n\n::: {.cell-output-display}\n![](vortex_spin_final.gif){width=110%}\n:::\n:::\n\n\n### Description\n\nGive yourself 30 seconds and stare deeply into the core of this vortex. Let your face relax, slow your breath, and be still. Now notice the cyclone drawing your attention away from the calamities of this world, and into the openness of luminous presence, if only for a moment. The spectrum of possibility awaits your return...\n\n<br>\n\n<hr>\n\n<br>\n\n## Code Choices (Exhibit 2)\n\nFor this piece, I created a custom C++ function based on the one from the Iterated Function Systems tutorial. I called it `unboxer_grid_circle()`, which simulates iterative transformations in a confined space. This produced the below image, which I then masked into a perfect circle using a different function called `raster_art_circle()`. I adjusted the scale to control the proportion of the visible part, centering the image. I used the \"MononokeMedium\" palette (I'm also a big Ghibli fan) to create an earthy, mysterious mood.\n\n::: text-center\n# 2. The Propagation of Mirth\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\nlibrary(ghibli)\n\n\nraster_art_circle <- function(mat, palette, trim = 0.001, scale = 0.55) {\n  zlim <- quantile(mat, c(trim, 1 - trim))\n  mat[mat < zlim[1]] <- zlim[1]\n  mat[mat > zlim[2]] <- zlim[2]\n\n  # Create circular mask\n  w <- nrow(mat)\n  h <- ncol(mat)\n  center_x <- w / 2\n  center_y <- h / 2\n  radius <- min(center_x, center_y)\n\n  mask <- outer(1:w, 1:h, function(i, j) {\n    (i - center_x)^2 + (j - center_y)^2 <= radius^2\n  })\n\n  mat[!mask] <- NA\n\n  op <- par(mar = c(0, 0, 0, 0))\n  image(\n    z = mat,\n    axes = FALSE,\n    asp = 1,\n    useRaster = TRUE,\n    col = palette,\n    na.rm = TRUE\n  )\n  par(op)\n}\n\nlibrary(ghibli)\npalette <- ghibli::ghibli_palette(\"MononokeMedium\", type = \"continuous\")\n\nRcpp::sourceCpp(\"unboxer_grid_circle.cpp\")\n\nset.seed(123)\nmat <- unboxer_grid_circle_core(iterations = 1e7,\n                                layers = 10,\n                                pixels = 800,\n                                border = 1.2)\n\nraster_art_circle(mat, palette = palette)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n### Description\n\nWhat if I told you that this is a map of the Earth, and on this map you are seeing the propagation of a truly human phenomenon? It isn't the exchange of currencies, the spreading of bad news, or the trading of fine furs. It is none other than the transmission of jokes over time: told during parties with cherished friends, overheard on buses by strangers, whispered over phones by newly enraptured lovers, or shared next to hospital beds with suffering patients, grateful for a brief respite. Each dot represents a new telling, a new smile, and a new precious instance of the sweet sound of laughter.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}