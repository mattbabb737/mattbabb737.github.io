{
  "hash": "c28708c956dd01449ba96e33d69deba5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Writing Efficient Functions\"\ndescription: \"Examples of computationally sensible and user-friendly function writing\"\nauthor:\n  - name: Matt Babb\ndate: 06-07-2025\ncategories: [Quarto, R] # self-defined categories\nimage: function_thumbnail.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\neditor: source\nembed-resources: true\necho: true\nwarning: false\nerror: false\ncode-fold: true\ncode-tools: true\n---\n\nThis assignment will challenge your function writing abilities. I'm not going \nto lie, these functions are difficult but well within your reach. I do, however,\nwant to recognize that not everyone is interested in being a \"virtuoso\" with \ntheir function writing. So, there are two options for this week's lab:\n\n- **Option 1:** Complete this lab assignment in search of virtuoso status with\nyour function writing\n- **Option 2:** Complete one of the difficult functions (Exercise 1 or Exercise\n2) and complete the \"Alternative Lab 6\". \n\n# Setting the Stage\n\nMy number one use case for writing functions and iteration / looping is to\nperform some exploration or modeling repeatedly for different \"tweaked\"\nversions. For example, our broad goal might be to fit a linear regression model\nto our data. However, there are often multiple choices that we have to make in\npractice:\n\n- Keep missing values or fill them in (imputation)? \n- Filter out outliers in one or more variables?\n\nWe can map these choices to **arguments** in a custom model-fitting function:\n\n- `impute`: TRUE or FALSE\n- `remove_outliers`: TRUE or FALSE\n\nA function that implements the analysis and allows for variation in these \nchoices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, impute, remove_outliers, mod) {\n    if (impute) {\n        df <- some_imputation_function(df)\n    }\n    \n    if (remove_outliers) {\n        df <- function_for_removing_outliers(df)\n    }\n    \n    lm(mod, data = df)\n}\n```\n:::\n\n\n# Helper Functions\n\n**Exercise 1:** Write a function that removes outliers in a dataset. The user\nshould be able to supply the dataset, the variables to remove outliers from, and\na threshold on the number of SDs away from the mean used to define outliers. \n*Hint 1: You will need to calculate a z-score to filter the values!*\n*Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nremove_outliers <- function(df, ..., sd_thresh = 3) {\n  vars <- rlang::enquos(...)\n\n  # Check all selected variables are numeric\n  all_numeric <- purrr::map_lgl(vars, ~ is.numeric(dplyr::pull(df, !!.x)))\n  if (!all(all_numeric)) {\n    stop(\"All selected variables must be numeric.\")\n  }\n\n  # Filter rows using if_all and tidy eval\n  df %>%\n    filter(if_all(all_of(tidyselect::vars_select(names(df), !!!vars)),\n                  ~ abs((.x - mean(.x, na.rm = TRUE)) / sd(.x, na.rm = TRUE)) < sd_thresh))\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nremove_outliers(diamonds, \n                price, \n                x, \n                y, \n                z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, \n                price, \n                color)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in remove_outliers(diamonds, price, color): All selected variables must be numeric.\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, \n                price,\n                x, \n                y, \n                z, \n                sd_thresh = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n**Exercise 2:** Write a function that imputes missing values for numeric \nvariables in a dataset. The user should be able to supply the dataset, the \nvariables to impute values for, and a function to use when imputing. \n*Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.*\n*Hint 2: The `replace_na()` function is helpful here!*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\n\nimpute_missing <- function(df, ..., impute_fun = mean) {\n  # Capture the selected variables\n  vars <- rlang::enquos(...)\n  \n  # Check all selected variables are numeric\n  all_numeric <- purrr::map_lgl(vars, ~ is.numeric(dplyr::pull(df, !!.x)))\n  if (!all(all_numeric)) {\n    stop(\"All selected variables must be numeric.\")\n  }\n\ndf %>%\n  mutate(across(\n    all_of(tidyselect::vars_select(names(df), !!!vars)),\n    ~ replace_na(.x, impute_fun(.x, na.rm = TRUE))\n  ))\n\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Testing that there are no NAs in the imputed dataset\n\nflights_clean <- impute_missing(nycflights13::flights, arr_delay, dep_delay)\n\n# Check for remaining NAs\nflights_clean %>%\n  summarize(\n    arr_delay_missing = sum(is.na(arr_delay)),\n    dep_delay_missing = sum(is.na(dep_delay))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  arr_delay_missing dep_delay_missing\n              <int>             <int>\n1                 0                 0\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               carrier)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in impute_missing(nycflights13::flights, arr_delay, carrier): All selected variables must be numeric.\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay, \n               impute_fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Checking to see if means and medians return different datasets\nflights_mean <- impute_missing(nycflights13::flights, arr_delay, dep_delay)\nflights_median <- impute_missing(nycflights13::flights, arr_delay, dep_delay, impute_fun = median)\n\nall.equal(flights_mean, flights_median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Component \\\"dep_delay\\\": Mean relative difference: 1.158239\"\n[2] \"Component \\\"arr_delay\\\": Mean relative difference: 1.725124\"\n```\n\n\n:::\n:::\n\n\n# Primary Function\n\n**Exercise 3:** Write a `fit_model()` function that fits a specified linear\nregression model for a specified dataset. The function should:\n\n- allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n- allow the user to specify if missing observations should be imputed\n(`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()`\nor `impute_missing()` functions to modify the data **before** the regression \nmodel is fit. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df,\n                      mod_formula,\n                      remove_outliers = FALSE,\n                      impute_missing = FALSE,\n                      impute_fun = mean,\n                      sd_thresh = 3,\n                      ...) {\n\n  if (impute_missing) {\n    df <- impute_missing(df, ..., impute_fun = mean)\n  }\n\n  if (remove_outliers) {\n    df <- remove_outliers(df, ..., sd_thresh = 3)\n  }\n\n  model <- lm(mod_formula, data = df)\n\n  return(model)\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  price, \n  carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mod_formula, data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n```\n\n\n:::\n:::\n\n\n# Iteration\n\nIn the `diamonds` dataset, we want to understand the relationship between\n`price` and size (`carat`). We want to explore variation along two choices:\n\n1. The variables included in the model. We'll explore 3 sets of variables:\n    - No further variables (just `price` and `carat`)\n    - Adjusting for `cut`\n    - Adjusting for `cut` and `clarity`\n    - Adjusting for `cut`, `clarity`, and `color`\n\n2. Whether or not to impute missing values\n\n3. Whether or not to remove outliers in the `carat` variable (we'll define\noutliers as cases whose `carat` is over 3 SDs away from the mean).\n\n## Parameters\n\nFirst, we need to define the set of parameters we want to iterate the\n`fit_model()` function over. The `tidyr` package has a useful function called\n`crossing()` that is useful for generating argument combinations. For each\nargument, we specify all possible values for that argument and `crossing()` \ngenerates all combinations. \n*Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- crossing(\n    impute = c(TRUE, FALSE),\n    remove_outliers = c(TRUE, FALSE), \n    mod = c(y ~ x1, \n            y ~ x1 + x2)\n)\ndf_arg_combos\n```\n:::\n\n\n**Exercise 4:** Use `crossing()` to create the data frame of argument\ncombinations for our analyses. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nformulas <- list(\n  price ~ carat,\n  price ~ carat + cut,\n  price ~ carat + cut + clarity,\n  price ~ carat + cut + clarity + color\n)\n\ndf_arg_combos <- tidyr::crossing(\n  impute = c(TRUE, FALSE),\n  remove_outliers = c(TRUE, FALSE),\n  mod_formula = formulas\n)\n\ndf_arg_combos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   impute remove_outliers mod_formula\n   <lgl>  <lgl>           <list>     \n 1 FALSE  FALSE           <formula>  \n 2 FALSE  FALSE           <formula>  \n 3 FALSE  FALSE           <formula>  \n 4 FALSE  FALSE           <formula>  \n 5 FALSE  TRUE            <formula>  \n 6 FALSE  TRUE            <formula>  \n 7 FALSE  TRUE            <formula>  \n 8 FALSE  TRUE            <formula>  \n 9 TRUE   FALSE           <formula>  \n10 TRUE   FALSE           <formula>  \n11 TRUE   FALSE           <formula>  \n12 TRUE   FALSE           <formula>  \n13 TRUE   TRUE            <formula>  \n14 TRUE   TRUE            <formula>  \n15 TRUE   TRUE            <formula>  \n16 TRUE   TRUE            <formula>  \n```\n\n\n:::\n:::\n\n\n## Iterating Over the Parameters\n\nWe've arrived at the final step! \n\n**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to\nevery combination of arguments from `diamonds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\nmodel_results <- df_arg_combos %>%\n  mutate(model = pmap(\n    list(impute, remove_outliers, mod_formula),\n    function(impute, remove_outliers, mod_formula) {\n      fit_model(\n        df = diamonds,\n        mod_formula = mod_formula,\n        impute_missing = impute,\n        remove_outliers = remove_outliers,\n        # vars for cleaning:\n        price, carat\n      )\n    }\n  ))\n\nprint(model_results, n = 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 4\n   impute remove_outliers mod_formula model \n   <lgl>  <lgl>           <list>      <list>\n 1 FALSE  FALSE           <formula>   <lm>  \n 2 FALSE  FALSE           <formula>   <lm>  \n 3 FALSE  FALSE           <formula>   <lm>  \n 4 FALSE  FALSE           <formula>   <lm>  \n 5 FALSE  TRUE            <formula>   <lm>  \n 6 FALSE  TRUE            <formula>   <lm>  \n 7 FALSE  TRUE            <formula>   <lm>  \n 8 FALSE  TRUE            <formula>   <lm>  \n 9 TRUE   FALSE           <formula>   <lm>  \n10 TRUE   FALSE           <formula>   <lm>  \n11 TRUE   FALSE           <formula>   <lm>  \n12 TRUE   FALSE           <formula>   <lm>  \n13 TRUE   TRUE            <formula>   <lm>  \n14 TRUE   TRUE            <formula>   <lm>  \n15 TRUE   TRUE            <formula>   <lm>  \n16 TRUE   TRUE            <formula>   <lm>  \n```\n\n\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}